<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>15-418 Final Project by riyasavla</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <a href="index.html"><h1 class="project-name">Packet Based Ray Tracer</h1> </a> 
      <h2 class="project-tagline">15-418 Final Project</h2>
      <a href="proposal.html" class="btn">Proposal</a>
      <a href="checkpoint.html" class="btn">Checkpoint</a>
      <a href="#" class="btn active">Final Report</a>
    </section>

    <section class="main-content">
        
        <h2 style="text-align:center">
<a id="checkpoint-report" class="anchor" href="index.html#checkpoint-report" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Final Report</h2>
        
      <h3>
<a id="summary" class="anchor" href="index.html#summary" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>SUMMARY</h3>

<p>I implemented a ray tracing algorithm that uses packet-based traversal techniques and relies of high quality SAH-based bounding volume hierarchies. I also implemented a simple parallel build algorithm for said bounding volume hierarchies.</p>

        <h3>
<a id="background" class="anchor" href="index.html#background" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>BACKGROUND</h3>
        
        <h3>
<a id="background" class="anchor" href="index.html#background" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>What is Ray Tracing ?</h3>
        
        <p>Ray Tracing is a technique for generating an image by tracing the path of light through pixels in an image plane and simulating the effects of its encounters with virtual objects. Ray tracing is capable of simulating a wide variety of optical effects, such as reflection and refraction, but at a higher computational cost than other algorithms like rasterization.</p>

        <p>Individual light rays are shot from the viewer (the eye, or the pixel ) into the scene. When a ray hits a surface, a shadow ray is shot from the intersection to test if a surface is visible to a light. If it is, the light contributes to the object’s color, otherwise not.</p>
        <center><img src="ray_trace.png" style="width:48%;"></center>
        
        <p>Since ray tracing follows the laws of physics, very photo-realistic images can be produced with it and there is increasing interest towards making the algorithm and the building of data structures it uses fast enough to be in interactive and real-time applications.</p>
        
        
        <h3>
<a id="background" class="anchor" href="index.html#background" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Bounding Volume Hierarchies</h3>  
        
        <p>Bounding Volume Hierarchies are tree structures used to organize primitives (primitives can be any polygons or spheres, most common are triangles) in a scene. The main objective in using a BVH to organize a scene is to minimize cost of finding closest intersection of ray with a primitive in the scene.  Each primitive is enclosed in a an axis aligned bounding box. Interior nodes store subset of primitives and aggregate bounding volumes for all primitives in subtree whereas leaf nodes store a list of primitives.</p>

        <p>The root node contains all the primitives and is recursively split into sub trees with a spatial partition chosen to minimize cost, where the cost of each spatial split is the sum of the surface area of the aggregate sub-tree bounding volume of each weighed by the  number of primitives it contains respectively.</p>
        

                <center><img src="bvh.png" style="width:100%;"></center>
        <br> 
        
        
                <h3>
<a id="background" class="anchor" href="index.html#background" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>APPROACH</h3>  
        
                        <h3>
<a id="background" class="anchor" href="index.html#background" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Building a BVH in Parallel</h3>  
        
        <p>Since building the BVH is essentially and divide and conquer problem, and each sub-tree is completely independent of others, different threads can work on splitting different sub-trees without any need for synchronization. There is also a significant performance gained by using a iterative stack-based method of building BVH as opposed to recursive calls. However, as illustrated in the diagram below, there is a significant bottleneck in the top levels of the tree. Available threads do not have enough sub-trees to work on.</p>
                        <center><img src="bvhnodelevel.jpg" style="width:75%;"></center>
    

        <p>One solution is to have all the threads work on one node by splitting the primitives amongst the threads as shown in the figure below. Each thread works on computing partial cost of splitting node by each partition plane. Once all the threads have finished this sep, one thread combines costs computed by all threads and finds the minimum cost partition.This does require a barrier but the next step is sequential, but it is small and fast.</p>
                                <center><img src="bvhhoriz.jpg" style="width:50%;"></center>
     
        
        <p>This approach works well in the higher levels of the tree when the number of primitives is far greater than number of threads available.  Once enough sub-trees are available, I switch to node-level parallelism.</p>
        
        
         <h3>
<a id="background" class="anchor" href="index.html#background" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Packet Based Traversal</h3>  
        
        
        <p>A ray’s point of intersection with the scene is found by descending nodes of the BVH and discarding all primitives contained in a sub-tree if the ray does not intersect with the bounding box of the node itself. The basic idea in a packet-based traversal method is to traverse the BVH one ‘packet’ at a time, rather than one ‘ray’ at a time. Each packet keeps track of its first active ray. If the first active ray intersects with a node, the entire packet immediately descends into the node. If not, then I find the next active ray in the packet, marking previous ones inactive. </p>
        
        <p>When a packet reaches a leaf, each ray in the packet must be intersected with the primitives in the leaf. I use SIMD instructions to perform this in parallel via Intel’s ISPC. For this, I store a packet of rays as a structure of arrays to be more compatible with SIMD loads and stores. Packet size is a multiple of the vector width being used so as to prevent under-utilization of vector lanes. Tracking the first active ray also helps save SIMD intersection calls on all inactive rays at the beginning of the packet.
</p>
        
         <center><img src="packet.png" style="width:50%;"></center>
        
        <p>However, there are costs associated with using packets as well. Divergence amongst BVH traversal and primitive intersections amongst individual rays in the packet leads to a performance drop for obvious reasons. For example, one ray can drag down an entire packet along with it into a node even if all other rays do not intersect with it. For this reason, it is important for rays belonging to one packet to be as coherent as possible. Then, the maximum benefits of packets are seen. As expected, packet-based traversal performs poorly on over-detailed scenes as primitives are too small for majority rays in a packet to intersect the same ones. </p>
        <p>One thing to note is that each ray can be traced completely independently of another and thus ray-tracing is an inherently parallel algorithm. The starter code I used (Fall 2015 15-462's assignment 3) already exploits this fact by including the functionality to have multiple threads working on different ‘tiles’ of an image concurrently. I compare the performance of my packet-based ISPC version of a ray tracer to single ray based one at different thread counts, later, in the results section. </p>
        
                        <h3>
<a id="background" class="anchor" href="index.html#background" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>RESULTS</h3>  
        
                        <h3>
<a id="background" class="anchor" href="index.html#background" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Parallel BVH Build</h3>  
        
       <p> Speedup compared to Single Threaded Build <br>
           Scene Size : ~1M Primitives </p>
            
        
                <center><img src="bvhspeedup.png" style="width:75%;"></center>
        
<p>>Maximum reached at 6 threads, which the the number of
    physical cores on the machine the program was run on.</p>
        
        <h3>
<a id="background" class="anchor" href="index.html#background" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Packet Traversal</h3>  
        
             <center><img src="mediumscenespeedup.jpg" style="width:75%;"></center>
        
        <p>This is the speedup achieved compared to the performance of single ray code running with one thread for a medium sized scene that fits in the L2 cache of the machine. Below is the rendered image. </p>
        
                <center><img src="banana.jpg" style="width:60%;"></center>
        <br>
        
        <p>Effect of Packet Size and Vector Width on Performance. </p>
        
                <center><img src="avx.png" style="width:75%;"></center>
        
        <p>There is a clear advantage to increasing packet size for highly coherent scenes where rays in a packet have similar behaviour with respect to many primitves. On the other hand, AVX provides almost no advantage over SSE-4, possibly due to higher possibility of divergence within a vector-width number of adjacent rays in a packet.</p>
        
        <p> This observation leads to the conclusion that packetizing camera and shadow rays makes sense because they have a much higher chance of being coherent with respect to one another. However, for diffuse bounces, rays are essentially in random directions and hence, indirect lighting computation does not benefit from packetization. In fact, I observed a performance drop when using packets for diffuse bounces compared to single ray code.</p>

       <h3>
        <a id="background" class="anchor" href="index.html#background" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>REFERENCES</h3>  

        <p>My starting point was the ray tracer I implemented in 15-462 (Fall 2015). I followed suggestions for parallelizing an SAH-BVH build given in Wald’s ‘On fast Construction of SAH-based Bounding Volume Hierarchies’ and ‘Ray Tracing Deformable Scenes Using Dynamic Bounding Volume Hierarchies’ for packet-based ray traversal.</p>
        
        


      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/riyasavla/15418-project-website">15-418 Final Project</a> is maintained by <a href="https://github.com/riyasavla">riyasavla</a>.</span>

        <span class="site-footer-credits">This page was modified from the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
